네, 알겠습니다. 당신이 원래 가지고 있던 README의 깊이 있는 내용과 제가 제안했던 가독성 개선 방안을 모두 결합하여, 온전하고 최적화된 마크다운 README를 제공해 드리겠습니다.

아래는 **깊이 있는 서술**과 **뛰어난 가독성**을 모두 갖춘 최종 버전의 README입니다.

-----

# No Redis, No Problem

### 제한된 인프라에서 고성능·고정합성 시스템을 실현한 실험형 백엔드 구조 설계

> 이 프로젝트는 단순한 서비스 구현이 아닌, **제약된 조건에서 최적의 설계를 도출하는 실험형 포트폴리오**입니다.  
> Redis, Kafka, 분산락 없이도 **실시간 API와 배치가 공존하는 고성능 시스템을 설계할 수 있는가**를 검증하고자 했습니다.

### 핵심 성과 요약

| 항목 | Before | After | 개선율 |
|:--- |:--- |:--- |:--- |
| **배치 처리 시간** | 81.48분 | 1.3분 | 약 **98%** 개선 |
| **API 응답속도** | 22.4초 | 0.43초 | 약 **96%** 단축 |
| **오류율** | 50% | 0% | 장애 전파 완전 해소 |
| **정합성 충돌** | 다수 | 0건 | 안정성 확보 (멀티 WAS 환경) |

## 📑 Table of Contents

1.  [프로젝트 개요](https://www.google.com/search?q=%231-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EC%9A%94)
2.  [기술 스택 및 실행 환경](https://www.google.com/search?q=%232-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D-%EB%B0%8F-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BD)
3.  [Part 1. 배치 성능 최적화 – JPA vs MyBatis](https://www.google.com/search?q=%233-part-1-%EB%B0%B0%EC%B9%98-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94--jpa-vs-mybatis)
    - [3.1. 실험의 배경](https://www.google.com/search?q=%2331-%EC%8B%A4%ED%97%98%EC%9D%98-%EB%B0%B0%EA%B2%BD)
    - [3.2. 성능 개선 타임라인](https://www.google.com/search?q=%2332-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8)
    - [3.3. MyBatis 최적화 과정](https://www.google.com/search?q=%2333-mybatis-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B3%BC%EC%A0%95)
    - [3.4. JPA 최적화 과정](https://www.google.com/search?q=%2334-jpa-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B3%BC%EC%A0%95)
    - [3.5. 최종 선택: 성능 vs 생산성](https://www.google.com/search?q=%2335-%EC%B5%9C%EC%A2%85-%EC%84%A0%ED%83%9D-%EC%84%B1%EB%8A%A5-vs-%EC%83%9D%EC%82%B0%EC%84%B1)
4.  [Part 2. 실시간 API 동시성 문제 해결 (단일 WAS)](https://www.google.com/search?q=%234-part-2-%EC%8B%A4%EC%8B%9C%EA%B0%84-api-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EB%8B%A8%EC%9D%BC-was)
    - [4.1. 문제 정의: DB Lock으로 인한 장애 전파](https://www.google.com/search?q=%2341-%EB%AC%B8%EC%A0%9C-%EC%A0%95%EC%9D%98-db-lock%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%9E%A5%EC%95%A0-%EC%A0%84%ED%8C%8C)
    - [4.2. 최적의 제어 지점 탐색](https://www.google.com/search?q=%2342-%EC%B5%9C%EC%A0%81%EC%9D%98-%EC%A0%9C%EC%96%B4-%EC%A7%80%EC%A0%90-%ED%83%90%EC%83%89)
    - [4.3. WAS 메모리 기반 제어 상세 설계](https://www.google.com/search?q=%2343-was-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B8%B0%EB%B0%98-%EC%A0%9C%EC%96%B4-%EC%83%81%EC%84%B8-%EC%84%A4%EA%B3%84)
5.  [Part 3. Redis 없는 분산 확장 구조 (멀티 WAS)](https://www.google.com/search?q=%235-part-3-redis-%EC%97%86%EB%8A%94-%EB%B6%84%EC%82%B0-%ED%99%95%EC%9E%A5-%EA%B5%AC%EC%A1%B0-%EB%A9%80%ED%8B%B0-was)
    - [5.1. 문제 정의: 분산 환경에서의 상태 동기화](https://www.google.com/search?q=%2351-%EB%AC%B8%EC%A0%9C-%EC%A0%95%EC%9D%98-%EB%B6%84%EC%82%B0-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EC%83%81%ED%83%9C-%EB%8F%99%EA%B8%B0%ED%99%94)
    - [5.2. 해결책: 동적 논리 파티셔닝](https://www.google.com/search?q=%2352-%ED%95%B4%EA%B2%B0%EC%B1%85-%EB%8F%99%EC%A0%81-%EB%85%BC%EB%A6%AC-%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D)
    - [5.3. 기술적 챌린지와 해결 과정](https://www.google.com/search?q=%2353-%EA%B8%B0%EC%88%A0%EC%A0%81-%EC%B1%8C%EB%A6%B0%EC%A7%80%EC%99%80-%ED%95%B4%EA%B2%B0-%EA%B3%BC%EC%A0%95)
    - [5.4. 아키텍처 및 플로우 차트](https://www.google.com/search?q=%2354-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%B0%A8%ED%8A%B8)
6.  [마무리하며: 프로젝트가 증명한 것](https://www.google.com/search?q=%236-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EA%B0%80-%EC%A6%9D%EB%AA%85%ED%95%9C-%EA%B2%83)

-----

## 1\. 프로젝트 개요

본 프로젝트는 다음과 같은 목표를 가지고 시작되었습니다.

- **대용량 데이터 배치 처리:** 사용자 3만 명, 주문 100만 건에 대한 등급 및 쿠폰 발급 배치를 효율적으로 처리
- **실시간 API와의 동시성 보장:** 배치 실행 중에도 등급/쿠폰과 관련된 API 요청이 안정적으로 처리되도록 보장
- **인프라 제약 극복:** Redis 등 외부 메모리 저장소 없이, 주어진 인프라(WAS, DB) 내에서 문제 해결

## 2\. 기술 스택 및 실행 환경

| 구분         | 스택 / 도구                      | 비고 |
|--------------|-------------------------------|:--- |
| **Language** | Java 17                       | |
| **Framework** | Spring Boot 3, MyBatis        | JPA 최종 선택 (MyBatis는 성능 비교) |
| **DB** | MySQL 8 (InnoDB)              | |
| **Infra** | Docker, Nginx (Reverse Proxy), JMeter | |
| **테스트/모니터링** | Apache JMeter, Docker Logs     | |
| **기타** | UUID 기반 PK 전략, 멀티 스레드 병렬 처리, 무 Redis 구조 | |

-----

## 3\. Part 1. 배치 성능 최적화 – JPA vs MyBatis

### 3.1. 실험의 배경

> 핵심 기능 구현을 앞두고 JPA와 MyBatis 중 어떤 ORM/Persistence 프레임워크를 선택할지 고민했습니다. 단순히 "MyBatis가 더 빠르다"는 막연한 이야기가 아닌, 두 프레임워크를 모두 초기 구현하고 성능을 비교하여 직접 체감하고자 했습니다.

### 3.2. 성능 개선 타임라인

```
JPA 초기     MyBatis 초기       MyBatis 최적화         JPA 병렬 최종
81분   ──────▶  48분     ──────▶      2분   ──────▶      1.3분   
```

**성능 테스트 결과 요약**
| 전략 | 실행 시간 | 주요 전략 | 특징 |
|:--- |:--- |:--- |:--- |
| **JPA 초기** | 81.48분 | 기본 IDENTITY 전략 | JPA의 JDBC Batch 미작동 |
| **MyBatis 초기** | 48.5분 | 단순 foreach 기반 Insert | SQL 제어로 개선 여지 존재 |
| **MyBatis 최종** | **2.0분** | `ExecutorType.BATCH` + `CASE WHEN` | SQL 통합 최적화로 극한의 성능 확보 |
| **JPA 최종** | **1.3분** | `UUID` + 병렬 처리 + `flush/clear` | 코드 일관성과 성능 동시 확보 |

### 3.3. MyBatis 최적화 과정

MyBatis를 통한 최적화는 2.0분이라는 놀라운 결과를 가져왔습니다. 이는 직접 SQL을 제어하는 MyBatis의 강력함을 보여주는 사례입니다.

- **1단계: 배치 처리 도입 (4.2배 개선)**: 쿼리마다 네트워크 왕복 및 커밋이 반복되는 병목을 해결하기 위해 `ExecutorType.BATCH`를 적용, 여러 파라미터를 한 번에 전송했습니다.
- **2단계: `foreach` `CASE WHEN` 최적화**: 배치 모드 적용 후에도 여전한 병목을 해소하기 위해, `foreach`와 `CASE WHEN` 구문으로 여러 업데이트/삽입 작업을 하나의 SQL 문으로 통합했습니다.

### 3.4. JPA 최적화 과정

JPA는 초기 성능이 매우 느렸지만, 5단계의 구조적인 최적화를 통해 최종적으로 MyBatis의 성능을 뛰어넘었습니다.

- **1단계: `IDENTITY` 제약의 한계 인식**: JPA의 기본 `IDENTITY` PK 전략은 JDBC 배치 insert를 방해하여 성능 저하의 주된 원인이었습니다.
- **2단계: `UPDATE` 전략 우회**: PK 문제 해결을 위해 미리 데이터를 insert 해두고 `UPDATE`하는 우회 전략을 시도, 57분에서 17분으로 단축했습니다.
- **3단계: `UUID` PK 및 영속성 컨텍스트 최적화**: `UUID`를 PK로 도입하여 WAS가 PK 생성 책임을 지게 함으로써 대량의 배치 insert가 가능해졌습니다.
- **4단계: 병렬 처리(멀티 6 스레드) 도입**: CPU/IO 병렬화를 통해 실질 처리량을 대폭 향상했습니다.
- **5단계: `UUID` 전략 고도화 (직렬화 vs 분산)**: 시간순 `UUID`의 직렬화 병목을 해소하기 위해 랜덤 `UUID`를 도입, 6초가량의 성능 차이를 실험적으로 확인했습니다.

### 3.5. 최종 선택: 성능 vs 생산성

**결론:** MyBatis도 병렬 처리 등으로 충분히 더 빠른 성능을 낼 수 있었지만, 본 프로젝트는 `생산성`, `유지보수`, `코드 일관성`을 더 중요한 변수로 판단하여 **JPA**를 최종 선택했습니다. 이 실험은 단순히 "빠르다"가 아닌, **지속 가능한 개발과 운영을 고려한 전략적 선택**이 중요함을 입증했습니다.

-----

## 4\. Part 2. 실시간 API 동시성 문제 해결 (단일 WAS)

### 4.1. 문제 정의: DB Lock으로 인한 장애 전파

> 배치 성능을 최적화한 후, 실시간 부하 테스트에서 DB Lock으로 인한 **커넥션 풀 고갈**과 **Socket Timeout** 에러가 발생했습니다. 이는 DB Lock이 점유되는 동안 시스템 자원을 고갈시키는 **'장애 전파(Cascading Failure)'** 현상이었습니다.

### 4.2. 최적의 제어 지점 탐색

| 전략명 | 제어 위치 | 장점 | 단점 | 선택 여부 |
|:--- |:--- |:--- |:--- |:--- |
| **DB Timeout** | DB | 빠른 에러 반환 | 근본적인 경합 해결 불가 | ❌ |
| **DB 플래그** | DB | Lock 없음 | 모든 요청에 DB I/O 발생 | ❌ |
| **WAS 메모리 플래그** | WAS | 빠름, 경합 최소 | 멀티 WAS 환경에서 동작 불가 | ✅ (단일 WAS 한정) |

**결론:** 가장 효율적인 제어 지점은 요청이 DB에 도달하기 전인 WAS라고 판단했습니다.

### 4.3. WAS 메모리 기반 제어 상세 설계

**전략:** WAS의 로컬 메모리에 `개별 유저 플래그`를 세워, Lock 경합이 예상되는 요청만 선별적으로 차단하고 `202 Accepted`를 즉시 반환했습니다.

- **전역 → 개별 플래그 전환**: 배치 시작 시 `전역 플래그`로 모든 API를 일시 차단하고, 집계 쿼리로 배치 대상 유저를 선별한 후 `개별 플래그`로 전환하여 비대상 유저의 API를 즉시 재허용했습니다. 이로써 **정합성, 자원 보호, 사용자 경험**을 모두 만족시켰습니다.

-----

## 5\. Part 3. Redis 없는 분산 확장 구조 (멀티 WAS)

### 5.1. 문제 정의: 분산 환경에서의 상태 동기화

> Part 2의 로컬 메모리 플래그는 WAS가 2대 이상인 Multi-WAS 환경에서는 동작하지 않습니다. Redis와 같은 분산 인프라 없이 **여러 WAS 인스턴스 간에 '배치 실행 여부'라는 상태를 일관성 있게 동기화**해야 하는 새로운 과제에 직면했습니다.

### 5.2. 해결책: 동적 논리 파티셔닝

- **발상 전환:** 상태를 '공유'하거나 '동기화'할 필요 없이, 각 WAS가 정해진 규칙에 따라 자신의 영역을 책임지는 **상태 비소유(Stateless)** 접근 방식을 채택했습니다.
- **구현 아이디어:** 각 WAS가 `userId % total_instances == my_index` 로 자신의 책임 영역을 판단하고, 자신의 영역에 해당하는 작업만 처리하는 구조입니다.

### 5.3. 기술적 챌린지와 해결 과정

| 질문 | 해결책 |
|:--- |:--- |
| **Q1. 전체 WAS 수는 어떻게 감지하는가?** | `was_instance` 테이블에 모든 인스턴스를 등록하고 DB에서 `count`로 감지합니다. |
| **Q2. 인스턴스 ID는 어떻게 식별하는가?** | 부팅 시 `UUID`를 생성하여 `was_instance` 테이블에 등록합니다. |
| **Q3. 오토스케일링은 어떻게 대응하는가?** | 배치 라운드 종료 시 인스턴스 수를 재확인하고, 작업 분할을 재계산합니다. |
| **Q4. 재분배 시 중복 처리를 막는 방법은?** | `step_execution_log`를 통해 완료된 라운드는 건너뛰어 멱등성을 보장합니다. |
| **Q5. 비정상 종료된 '좀비 인스턴스'는 어떻게 파악하는가?** | 30초마다 `하트비트(Heartbeat)`를 갱신하고, 갱신되지 않은 인스턴스는 제외합니다. |

> **현실적 한계:** 이 방식은 100% 실시간 감지는 아니지만, 장애 감지와 시스템 부하 사이의 합리적인 균형을 잡은 결과입니다.

### 5.4. 아키텍처 및 플로우 차트

**아키텍처 개요**

> **설명:** Nginx는 RR(Round Robin) 방식으로 요청을 분산하고, WAS는 요청의 `userId`를 기반으로 자신의 책임 영역을 판단합니다. `was_instance`와 `step_execution_log` 테이블을 통해 분산 상태를 관리하는 구조입니다.

**오토스케일링 대응 플로우**

> **설명:** 오토스케일링 시점에서 배치를 중단하고, 미처리 유저에 대해서만 작업을 재개하는 흐름입니다. `step_execution_log`를 기반으로 멱등성을 유지하며 분산을 재계산하는 과정이 핵심입니다.

-----

## 6\. 마무리하며: 프로젝트가 증명한 것

이 프로젝트는 단순한 백엔드 구현이 아니라, \*\*"제약 조건 하에서의 실질적 대안 구조 설계"\*\*를 목표로 진행되었습니다.

- **Redis 없이도** 고성능 + 정합성 보장 시스템을 구축할 수 있습니다.
- **JPA**도 구조적 최적화를 거치면 MyBatis에 근접하거나 앞설 수 있습니다.
- **정합성, 동시성, 성능**이라는 실무 핵심 요소를 동시에 만족시키는 것은 설계적 통찰이 중요합니다.

이 실험은 단순 백엔드 구현이 아니라, **설계자적 관점**에서 복잡한 트레이드오프를 조율한 결과물입니다.